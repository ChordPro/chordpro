#! perl

use strict;
use warnings;
use utf8;

# Implementation of ChordPro::Wx::EditorPanel_wxg details.

package ChordPro::Wx::EditorPanel;

# ChordPro::Wx::EditorPanel_wxg is generated by wxGlade and contains
# all UI associated code.

use parent qw( ChordPro::Wx::EditorPanel_wxg );

use Wx qw[:everything];
use Wx::Locale gettext => '_T';
use ChordPro::Wx::Utils;
use ChordPro::Utils qw( demarkup is_macos );

sub new {
    my( $self, $parent, $id, $pos, $size, $style, $name ) = @_;
    $parent = undef              unless defined $parent;
    $id     = -1                 unless defined $id;
    $pos    = wxDefaultPosition  unless defined $pos;
    $size   = wxDefaultSize      unless defined $size;
    $name   = ""                 unless defined $name;

    $self = $self->SUPER::new( $parent, $id, $pos, $size, $style, $name );

    # By default the TextCtrl on MacOS substitutes smart quotes and dashes.
    # Note that OSXDisableAllSmartSubstitutions requires an augmented
    # version of wxPerl.
    $self->{t_source}->OSXDisableAllSmartSubstitutions
      if $self->{t_source}->can("OSXDisableAllSmartSubstitutions");

    $self->Layout;
    return $self;

}

sub log {
    my $self = shift;
    wxTheApp->GetTopWindow->log(@_);
}

################ API Functions ################

sub refresh {
    my ( $self ) = @_;
    # Enable/disable menu items.
    for ( $self->GetParent->{main_menubar} ) {
	$_->FindItem(wxID_UNDO)->Enable($self->{t_source}->CanUndo);
	$_->FindItem(wxID_REDO)->Enable($self->{t_source}->CanRedo);
    }
}

sub open {
    my ( $self, $create ) = @_;
    return unless $self->checksaved;

    if ( $create ) {
	$self->newfile;
    }
    else {
	$self->opendialog;
    }
}

sub opendialog {
    my ($self) = @_;
    my $fd = Wx::FileDialog->new
      ($self, _T("Choose ChordPro file"),
       "", "",
       "ChordPro files (*.cho,*.crd,*.chopro,*.chord,*.chordpro,*.pro)|*.cho;*.crd;*.chopro;*.chord;*.chordpro;*.pro".
       (is_macos ? ";*.txt" : "|All files|*.*"),
       0|wxFD_OPEN|wxFD_FILE_MUST_EXIST,
       wxDefaultPosition);
    my $ret = $fd->ShowModal;
    if ( $ret == wxID_OK ) {
	$self->openfile( $fd->GetPath, 1 );
    }
    $fd->Destroy;
}

sub openfile {
    my ( $self, $file, $checked ) = @_;

    # File tests fail on Windows, so bypass when already checked.
    unless ( $checked || -f -r $file ) {
	$self->log( 'W',  "Error opening $file: $!",);
	my $md = Wx::MessageDialog->new
	  ( $self,
	    "Error opening $file: $!",
	    "File open error",
	    wxOK | wxICON_ERROR );
	my $ret = $md->ShowModal;
	$md->Destroy;
	return;
    }
    unless ( $self->{t_source}->LoadFile($file) ) {
	$self->log( 'W',  "Error opening $file: $!",);
	my $md = Wx::MessageDialog->new
	  ( $self,
	    "Error opening $file: $!",
	    "File load error",
	    wxOK | wxICON_ERROR );
	$md->ShowModal;
	$md->Destroy;
	return;
    }
    #### TODO: Get rid of selection on Windows
    $self->{_currentfile} = $file;
    if ( $self->{t_source}->GetValue =~ /^\{\s*t(?:itle)?[: ]+([^\}]*)\}/m ) {
	my $title = demarkup($1);
	my $n = $self->{t_source}->GetNumberOfLines;
	$self->log( 'S', "Loaded: $title ($n line" . ( $n == 1 ? "" : "s" ) . ")");
	$self->{sz_source}->GetStaticBox->SetLabel($title);
    }
    else {
	my $n = $self->{t_source}->GetNumberOfLines;
	$self->log( 'S', "Loaded: $file ($n line" . ( $n == 1 ? "" : "s" ) . ")");
    }
    $self->SetTitle( $self->{_windowtitle} = $file);

    $self->{prefs_xpose} = 0;
    $self->{prefs_xposesharp} = 0;
    return 1;
}

sub newfile {
    my ( $self ) = @_;
    undef $self->{_currentfile};

    my $file = $self->{prefs_tmplfile};
    my $content = "{title: New Song}\n\n";
    if ( $file ) {
	$self->log( 'I', "Loading template $file" );
	if ( -f -r $file ) {
	    if ( $self->{t_source}->LoadFile($file) ) {
		$content = "";
	    }
	    else {
		$content = "# Error opening template $file: $!\n\n" . $content;
	    }
	}
	else {
	    $content = "# Error opening template $file: $!\n\n" . $content;
	}
     }
    $self->{t_source}->SetValue($content) unless $content eq "";
    $self->{t_source}->SetModified(0);
    $self->log( 'S', "New file");
    $self->{prefs_xpose} = 0;
    $self->{prefs_xposesharp} = 0;
}

sub checksaved {
    my ( $self ) = @_;
    return 1 unless ( $self->{t_source} && $self->{t_source}->IsModified );
    if ( $self->{_currentfile} ) {
	my $md = Wx::MessageDialog->new
	  ( $self,
	    "File " . $self->{_currentfile} . " has been changed.\n".
	    "Do you want to save your changes?",
	    "File has changed",
	    0 | wxCANCEL | wxYES_NO | wxYES_DEFAULT | wxICON_QUESTION );
	my $ret = $md->ShowModal;
	$md->Destroy;
	return if $ret == wxID_CANCEL;
	if ( $ret == wxID_YES ) {
	    $self->save_as( $self->{_currentfile} );
	}
    }
    else {
	my $md = Wx::MessageDialog->new
	  ( $self,
	    "Do you want to save your changes?",
	    "Contents has changed",
	    0 | wxCANCEL | wxYES_NO | wxYES_DEFAULT | wxICON_QUESTION );
	my $ret = $md->ShowModal;
	$md->Destroy;
	return if $ret == wxID_CANCEL;
	if ( $ret == wxID_YES ) {
	    return if $self->OnSaveAs == wxID_CANCEL;
	}
    }
    return 1;
}

sub saveas {
    my ( $self ) = @_;
    my $fd = Wx::FileDialog->new
      ($self, _T("Choose output file"),
       "", "",
       "*.cho",
       0|wxFD_SAVE|wxFD_OVERWRITE_PROMPT,
       wxDefaultPosition);
    my $ret = $fd->ShowModal;
    if ( $ret == wxID_OK ) {
	$self->save_as( $self->{_currentfile} = $fd->GetPath );
    }
    $fd->Destroy;
    return $ret;
}

sub save_as {
    my ( $self, $file ) = @_;
    $self->{t_source}->SaveFile($file);
    $self->SetTitle( $self->{_windowtitle} = $file);
    $self->log( 'S',  "Saved." );
}

sub save {
    my ( $self ) = @_;
    goto &saveas unless $self->{_currentfile};
    $self->save_as( $self->{_currentfile} );
}

sub undo {
    my ( $self ) = @_;
    $self->{t_source}->CanUndo
      ? $self->{t_source}->Undo
	: $self->log( 'I', "Sorry, can't undo yet");
}

sub redo {
    my ( $self ) = @_;
    $self->{t_source}->CanRedo
      ? $self->{t_source}->Redo
	: $self->log( 'I', "Sorry, can't redo yet");
}

sub cut {
    my ( $self ) = @_;
    $self->{t_source}->Cut;
}

sub paste {
    my ( $self ) = @_;
    $self->{t_source}->Paste;
}

sub delete {
    my ( $self ) = @_;
    my ( $from, $to ) = $self->{t_source}->GetSelection;
    $self->{t_source}->Remove( $from, $to ) if $from < $to;
}

sub alert {
    my ( $self ) = @_;
    $self->{b_msgs}->SetBackgroundColour(Wx::Colour->new(255, 0, 0));
}

################ Event Handlers ################

sub OnText {
    my ($self, $event) = @_;
    $self->{t_source}->SetModified(1);
}

sub OnPreferences {
    my ( $self, $event ) = @_;
    $self->GetParent->OnPreferences($event);
}

sub OnPreview {
    my ( $self, $event ) = @_;
    $event = Wx::CommandEvent->new( wxEVT_COMMAND_MENU_SELECTED,
				    $self->wxID_PREVIEW );
    Wx::PostEvent( $self->GetParent, $event );
}

sub OnShowMessages {
    my ( $self, $event ) = @_;
    $self->{b_msgs}->SetBackgroundColour(wxNullColour);
    $self->GetParent->{_prev_mode} = "EDIT";
    $self->GetParent->select_mode("MSGS");
}

1;

