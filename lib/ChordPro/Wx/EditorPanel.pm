#! perl

use v5.26;
use utf8;

# Implementation of ChordPro::Wx::EditorPanel_wxg details.

package ChordPro::Wx::EditorPanel;

# ChordPro::Wx::EditorPanel_wxg is generated by wxGlade and contains
# all UI associated code.

use parent qw( ChordPro::Wx::EditorPanel_wxg );

use Wx qw[:everything];
use Wx::Locale gettext => '_T';
use ChordPro::Wx::Config;
use ChordPro::Wx::Utils;
use ChordPro::Utils qw( demarkup is_macos is_msw );
use ChordPro::Paths;
use File::Basename;

my $stc;
my $wv;

sub new {
    my( $self, $parent, $id, $pos, $size, $style, $name ) = @_;
    $parent = undef              unless defined $parent;
    $id     = -1                 unless defined $id;
    $pos    = wxDefaultPosition  unless defined $pos;
    $size   = wxDefaultSize      unless defined $size;
    $name   = ""                 unless defined $name;

    $self = $self->SUPER::new( $parent, $id, $pos, $size, $style, $name );

    # By default the TextCtrl on MacOS substitutes smart quotes and dashes.
    # Note that OSXDisableAllSmartSubstitutions requires an augmented
    # version of wxPerl.
    $self->{t_editor}->OSXDisableAllSmartSubstitutions
      if $self->{t_editor}->can("OSXDisableAllSmartSubstitutions");

    # Try Styled Text Control (Scintilla). This required an updated
    # version of Wx.
    $stc = eval { use Wx::STC; 1 };
    if ( $stc ) {
	# This may decide otherwise.
	$self->setup_scintilla;
    }

    $wv = is_msw ? 0 : eval { use Wx::WebView; 1 };
    if ( $wv ) {
	$self->setup_webview;
    }

    $self->{sw_e_p}->Unsplit(undef);
    $self->{sw_ep_m}->Unsplit(undef);
    return $self;

}

sub log {
    my $self = shift;
    wxTheApp->GetTopWindow->log(@_);
}

################ API Functions ################

sub setup_scintilla {
    my ( $self ) = @_;

    # Replace the placeholder Wx::TextCtrl.
    $stc = Wx::StyledTextCtrl->new( $self->{p_left},
				    wxID_ANY );

    # Check for updated STC.
    for ( qw( IsModified DiscardEdits MarkDirty ) ) {
	unless ( $stc->can($_) ) {
	    # Unpatched Wx, missing methods.
	    $stc->Destroy;
	    return;
	}
    }

    $self->{sz_editor}->Replace( $self->{t_editor}, $stc, 1 );
    $self->{t_editor}->Destroy;
    $self->{t_editor} = $stc;
    $self->{sz_editor}->Layout;

    $stc->SetLexer(wxSTC_LEX_CONTAINER);
    $stc->SetKeyWords(0,
		      [qw( album arranger artist capo chord chorus
			   column_break columns comment comment_box
			   comment_italic composer copyright define
			   diagrams duration end_of_bridge end_of_chorus
			   end_of_grid end_of_tab end_of_verse grid
			   highlight image key lyricist meta new_page
			   new_physical_page new_song no_grid pagesize
			   pagetype sorttitle start_of_bridge
			   start_of_chorus start_of_grid start_of_tab
			   start_of_verse subtitle tempo time title
			   titles transpose year )
		      ]);

    Wx::Event::EVT_STC_STYLENEEDED($self, -1, $self->can('OnStyleNeeded'));

    $stc->StyleClearAll;
    # 0 - basic
    # 1 - comments
    $stc->StyleSetSpec( 1, "bold,fore:grey" );
    # 2 - Keywords
    $stc->StyleSetSpec( 2, "bold,fore:grey" );
    # 3 - Brackets
    $stc->StyleSetSpec( 3, "bold,fore:blue" );
    # 4 - Chords
    $stc->StyleSetSpec( 4, "fore:red" );
    # 5 - Directives
    $stc->StyleSetSpec( 5, "bold,fore:indigo" );
    # 6 - Directive arguments
    $stc->StyleSetSpec( 6, "fore:orange" );

    # For linenumbers.
    $stc->SetMarginWidth( 0, 40 ); # TODO

}

sub style_text {
    my ( $self, $stc ) = @_;

    # Scintilla uses byte indices.
    use Encode;
    my $text  = Encode::encode_utf8($stc->GetText);

    my $style = sub {
	my ( $re, @styles ) = @_;
	pos($text) = 0;
	while ( $text =~ m/$re/g ) {
	    my @s = @styles;
	    die("!!! ", scalar(@{^CAPTURE}), ' ', scalar(@s)) unless @s == @{^CAPTURE};
	    my $end = pos($text);
	    my $start = $end - length($&);
	    my $group = 0;
	    while ( $start < $end ) {
		my $l = length(${^CAPTURE[$group++]});
		$stc->StartStyling( $start, 0 );
		$stc->SetStyling( $l, shift(@s) );
		$start += $l;
	    }
	}
    };

    # Comments/
    $style->( qr/^(#.*)/m, 1 );
    # Directives.
    $style->( qr/^(\{)([-\w!]+)([: ]+)(.*)(\})/m, 3, 5, 3, 6, 3 );
    # Chords.
    $style->( qr/(\[)([^\[\]]*)(\])/m, 3, 4, 3 );
}

sub setup_webview {
    my ( $self ) = @_;
    my $w = Wx::WebView::New( $self->{p_right},
			      wxID_ANY,
			      CP->findres( "chordpro-icon.png",
					   class => "icons" ) );
    $self->{sz_preview}->Replace( $self->{webview}, $w, 1 );
    $self->{webview}->Destroy;
    $self->{webview} = $w;
    $self->{sz_preview}->Layout;
}

sub setup_menubar {
    my ( $self ) = @_;

    my $mb =
    make_menubar( $self,
      [ [ wxID_FILE,
	  [ [ wxID_NEW, "", "Create another ChordPro document", "OnNew" ],
	    [ wxID_OPEN, "", "Open an existing ChordPro document", "OnOpen" ],
	    [],
	    [ wxID_SAVE, "", "Save the current ChordPro file", "OnSave" ],
	    [ wxID_SAVEAS, "", "Save under a different name", "OnSaveAs" ],
	    [],
	    [ wxID_ANY, "Hide/Show messages",
	      "Hide or show the messages pane", "OnWindowMessages" ],
	    [ wxID_ANY, "Save messages",
	      "Save the messages to a file", "OnMessagesSave" ],
	    [ wxID_ANY, "Clear messages",
	      "Clear the current messages", "OnMessagesClear" ],
	    [],
	    [ wxID_EXIT, "", "Close window and exit", "OnClose" ],
	  ]
	],
	[ wxID_EDIT,
	  [ [ wxID_UNDO,   "OnUndo" ],
	    [ wxID_REDO,   "OnRedo" ],
	    [],
	    [ wxID_CUT,    "OnCut" ],
	    [ wxID_COPY,   "OnCopy" ],
	    [ wxID_PASTE,  "OnPaste" ],
	    [ wxID_DELETE, "OnDelete" ],
	    [],
	    [ wxID_ANY, "Preferences...\tCtrl-R",
	      "Preferences", "OnPreferences" ],
	  ]
	],
	[ wxID_ANY, "Tasks",
	  [ [ wxID_ANY, "Default preview\tCtrl-P",
	      "Preview with default formatting", "OnPreview" ],
	    [ wxID_ANY, "No chord diagrams",
	      "Preview without chord diagrams", "OnPreviewNoDiagrams" ],
	    [ wxID_ANY, "Lyrics only",
	      "Preview just the lyrics", "OnPreviewLyricsOnly" ],
	    [ wxID_ANY, "More...",
	      "Transpose, transcode, and more", "OnPreviewMore" ],
	    [],
	    [ wxID_ANY, "Hide/Show Preview",
	      "Hide or show the preview pane", "OnWindowPreview" ],
	    [ wxID_ANY, "Save preview", "Save the preview to a PDF",
	      "OnPreviewSave" ],
	  ]
	],
	[ wxID_HELP,
	  [ [ wxID_ANY, "ChordPro file format",
	      "Help about the ChordPro file format", "OnHelp_ChordPro" ],
	    [ wxID_ANY, "ChordPro config files",
	      "Help about the config files", "OnHelp_Config" ],
	    [],
	    [ wxID_ANY, "Enable debug info in PDF",
	      "Add sources and configs to the PDF for debugging", 1,
	      "OnHelp_DebugInfo" ],
	    [],
	    [ wxID_ABOUT, "", "About WxChordPro", "OnAbout" ],
	  ]
	]
      ] );

    my $menu = $mb->FindMenu("Tasks");
    $menu = $mb->GetMenu($menu);
    # Append separator.
    $menu->AppendSeparator if @{$state{tasks}};
    for my $task ( @{$state{tasks} } ) {
	my ( $desc, $file ) = @$task;
	my $id = Wx::NewId();
	# Append to the menu.
	$menu->Append( $id, $desc, _T("Custom task: ").$desc );
	Wx::Event::EVT_MENU
	    ( $self->GetParent, $id,
	      sub {
		  my ( $self, $event ) = @_;
		  $self->preview( [ "--config", $file ] );
	      } );
    }
}

################ API Functions ################

sub refresh {
    my ( $self ) = @_;
    my $parent = $self->GetParent;

    my $log = Wx::LogTextCtrl->new( $self->{t_messages} );
#      my    $log = Wx::LogStderr->new;
    Wx::Log::SetActiveTarget( $log );
    $self->setup_menubar;
    $self->log( 'I', "Using " .
		( ref($self->{p_editor}{t_editor}) eq 'Wx::TextCtrl'
		  ? "basic" : "styled") . " text editor" );

    $self->log( 'I', "Using " .
		( ref($self->{p_editor}{webview}) eq 'Wx::WebView'
		  ? "embedded" : "external") . " PDF viewer" );


    my $font = $state{fonts}[$preferences{editfont}]{font};
    $font->SetPointSize($preferences{editsize});
    $self->{t_editor}->SetFont($font);
    $self->{t_editor}->SetBackgroundColour
      (Wx::Colour->new($preferences{editcolour}));

}

sub open {
    my ( $self, $create ) = @_;
    return unless $self->checksaved;

    if ( $create ) {
	$self->newfile;
    }
    else {
	$self->opendialog;
    }
}

sub opendialog {
    my ($self) = @_;
    my $fd = Wx::FileDialog->new
      ($self, _T("Choose ChordPro file"),
       dirname($state{recents}[0]//""), "",
       "ChordPro files (*.cho,*.crd,*.chopro,*.chord,*.chordpro,*.pro)|*.cho;*.crd;*.chopro;*.chord;*.chordpro;*.pro".
       (is_macos ? ";*.txt" : "|All files|*.*"),
       0|wxFD_OPEN|wxFD_FILE_MUST_EXIST,
       wxDefaultPosition);
    my $ret = $fd->ShowModal;
    if ( $ret == wxID_OK ) {
	$self->openfile( $fd->GetPath, 1 );
    }
    $fd->Destroy;
}

sub openfile {
    my ( $self, $file, $checked ) = @_;

    # File tests fail on Windows, so bypass when already checked.
    unless ( $checked || -f -r $file ) {
	$self->log( 'W',  "Error opening $file: $!",);
	my $md = Wx::MessageDialog->new
	  ( $self,
	    "Error opening $file: $!",
	    "File open error",
	    wxOK | wxICON_ERROR );
	my $ret = $md->ShowModal;
	$md->Destroy;
	return;
    }
    unless ( $self->{t_editor}->LoadFile($file) ) {
	$self->log( 'W',  "Error opening $file: $!",);
	my $md = Wx::MessageDialog->new
	  ( $self,
	    "Error opening $file: $!",
	    "File load error",
	    wxOK | wxICON_ERROR );
	$md->ShowModal;
	$md->Destroy;
	return;
    }
    #### TODO: Get rid of selection on Windows
    $state{currentfile} = $file;
    use List::Util qw(uniq);
    @{$state{recents}} = uniq( $file, @{$state{recents}} );

    if ( $self->{t_editor}->GetText =~ /^\{\s*t(?:itle)?[: ]+([^\}]*)\}/m ) {
	my $title = demarkup($1);
	my $n = $self->{t_editor}->GetLineCount;
	$self->log( 'S', "Loaded: $title ($n line" . ( $n == 1 ? "" : "s" ) . ")");
	$self->{l_status}->SetLabel($title);
    }
    else {
	my $n = $self->{t_editor}->GetLineCount;
	$self->{l_status}->SetLabel(basename($file));
	$self->log( 'S', "Loaded: $file ($n line" . ( $n == 1 ? "" : "s" ) . ")");
    }
    $self->GetParent->SetTitle( $state{windowtitle} = $file);

    # Default is no transposing.
    $preferences{xpose_from} = $preferences{xpose_to} = 0;
    $preferences{xpose_acc} = 0;

    return 1;
}

sub newfile {
    my ( $self ) = @_;
    delete $state{currentfile};

    my $file = $preferences{tmplfile};
    my $content = "{title: New Song}\n\n";
    if ( $file ) {
	$self->log( 'I', "Loading template $file" );
	if ( -f -r $file ) {
	    if ( $self->{t_editor}->LoadFile($file) ) {
		$content = "";
	    }
	    else {
		$content = "# Error opening template $file: $!\n\n" . $content;
	    }
	}
	else {
	    $content = "# Error opening template $file: $!\n\n" . $content;
	}
     }
    $self->{t_editor}->SetText($content) unless $content eq "";
    $self->{t_editor}->SetModified(0);
    $self->log( 'S', "New file");
    $preferences{xpose_from} = $preferences{xpose_to} = 0;
    $preferences{xpose_acc} = 0;
}

sub checksaved {
    my ( $self ) = @_;
    return 1 unless ( $self->{t_editor} && $self->{t_editor}->IsModified );
    if ( $state{currentfile} ) {
	my $md = Wx::MessageDialog->new
	  ( $self,
	    "File " . $state{currentfile} . " has been changed.\n".
	    "Do you want to save your changes?",
	    "File has changed",
	    0 | wxCANCEL | wxYES_NO | wxYES_DEFAULT | wxICON_QUESTION );
	my $ret = $md->ShowModal;
	$md->Destroy;
	return if $ret == wxID_CANCEL;
	if ( $ret == wxID_YES ) {
	    $self->save_as( $state{currentfile} );
	}
    }
    else {
	my $md = Wx::MessageDialog->new
	  ( $self,
	    "Do you want to save your changes?",
	    "Contents has changed",
	    0 | wxCANCEL | wxYES_NO | wxYES_DEFAULT | wxICON_QUESTION );
	my $ret = $md->ShowModal;
	$md->Destroy;
	return if $ret == wxID_CANCEL;
	if ( $ret == wxID_YES ) {
	    return if $self->OnSaveAs == wxID_CANCEL;
	}
    }
    return 1;
}

sub saveas {
    my ( $self ) = @_;
    my $fd = Wx::FileDialog->new
      ($self, _T("Choose output file"),
       "", "",
       "*.cho",
       0|wxFD_SAVE|wxFD_OVERWRITE_PROMPT,
       wxDefaultPosition);
    my $ret = $fd->ShowModal;
    if ( $ret == wxID_OK ) {
	$self->save_as( $state{currentfile} = $fd->GetPath );
    }
    $fd->Destroy;
    return $ret;
}

my $prv;

sub preview {
    my ( $self, $args, %opts ) = @_;
    use ChordPro::Wx::Preview;
    $prv //= ChordPro::Wx::Preview->new( panel => $self );

    my $mod = $self->{t_editor}->IsModified;
    my $preview_cho = $prv->preview_cho;
    unlink($preview_cho);
    my $fd;
    if ( open( $fd, '>:utf8', $preview_cho )
	 and print $fd ( $self->{t_editor}->GetText )
	 and close($fd) ) {
	$prv->preview( $args, %opts );
    }
    else {
	$self->log( 'E', "$preview_cho: $!" );
	$self->alert;
    }
}

my $astyle;

sub prepare_annotations {
    my ( $self ) = @_;

    return unless $stc->isa('Wx::StyledTextCtrl');

    $astyle = 1 + wxSTC_STYLE_LASTPREDEFINED;
    $stc->AnnotationClearAll;
    $stc->AnnotationSetVisible(wxSTC_ANNOTATION_BOXED);
    $stc->StyleSetBackground( $astyle, Wx::Colour->new(255, 255, 160) );
    $stc->StyleSetForeground( $astyle, wxRED );

    if ( $stc->can("StyleGetSizeFractional") ) { # Wx 3.002
	$stc->StyleSetSizeFractional	# size * 100
	  ( $astyle,
	    ( $stc->StyleGetSizeFractional
	      ( wxSTC_STYLE_DEFAULT ) * 4 ) / 5 );
    }
    return 1;
}

sub add_annotation {
    my ( $self, $line, $message ) = @_;

    return unless $stc->isa('Wx::StyledTextCtrl');

    $stc->AnnotationSetText( $line, $message );
    $stc->AnnotationSetStyle( $line, $astyle );
}

sub alert {
    my ( $self ) = @_;
    $self->{bmb_messages}->SetBackgroundColour(Wx::Colour->new(255, 0, 0));
}

################ Event Handlers ################

sub OnNew {
    my ( $self ) = @_;
    return unless $self->checksaved;
    $self->GetParent->select_mode("initial");
}

sub OnOpen {
    my ( $self ) = @_;
    $self->open(0);
}

sub OnSaveAs {
    my ( $self, $file ) = @_;
    $self->{t_editor}->SaveFile($file);
    $state{windowtitle} = $file;
    $self->log( 'S',  "Saved." );
}

sub OnSave {
    my ( $self ) = @_;
    goto &saveas unless $state{currentfile};
    $self->save_as( $state{currentfile} );
}

sub OnUndo {
    my ( $self ) = @_;
    $self->{t_editor}->CanUndo && $self->{t_editor}->Undo;
}

sub OnRedo {
    my ( $self ) = @_;
    $self->{t_editor}->CanRedo && $self->{t_editor}->Redo;
}

sub OnCut {
    my ( $self ) = @_;
    $self->{t_editor}->Cut;
}

sub OnPaste {
    my ( $self ) = @_;
    $self->{t_editor}->Paste;
}

sub OnDelete {
    my ( $self ) = @_;
    my ( $from, $to ) = $self->{t_editor}->GetSelection;
    $self->{t_editor}->Remove( $from, $to ) if $from < $to;
}

sub OnText {
    my ($self, $event) = @_;
    $self->{t_editor}->SetModified(1);
}

sub OnPreviewSave {
    my ( $self, $event ) = @_;
    return unless $prv;
    $prv->save;
}

sub OnPreferences {
    my ( $self, $event ) = @_;
    use ChordPro::Wx::PreferencesDialog;
    $self->{d_prefs} ||= ChordPro::Wx::PreferencesDialog->new($self, -1, "Preferences");
    restorewinpos( $self->{d_prefs}, "prefs" );
    my $ret = $self->{d_prefs}->ShowModal;
    savewinpos( $self->{d_prefs}, "prefs" );
    $self->GetParent->SavePreferences if $ret == wxID_OK;
}

sub previewtooltip {
    my ( $self ) = @_;
    if ( $self->{sw_e_p}->IsSplit ) {
	$self->{bmb_preview}->SetToolTip(_T("Hide preview"));
    }
    else {
	$self->{bmb_preview}->SetToolTip(_T("Generate and show preview"));
    }
}

sub messagestooltip {
    my ( $self ) = @_;
    if ( $self->{sw_ep_m}->IsSplit ) {
	$self->{bmb_messages}->SetToolTip(_T("Hide messages"));
    }
    else {
	$self->{bmb_messages}->SetToolTip(_T("Show messages"));
    }
}

sub OnPreview {			# for menu
    my ( $self, $event ) = @_;
    $self->preview( [] );
    $self->previewtooltip;
}

sub OnShowPreview {		# for button
    my ( $self, $event ) = @_;
    $self->{sw_e_p}->IsSplit
      ? goto &OnPreviewClose
      : goto &OnPreview;
}

sub OnPreviewLyricsOnly {
    my ( $self, $event ) = @_;
    $self->preview( [ '--lyrics-only' ] );
    $self->previewtooltip;
}

sub OnPreviewNoDiagrams {
    my ( $self, $event ) = @_;
    $self->preview( [ '--no-chord-grids' ] );
    $self->previewtooltip;
}

#               C      D      E  F      G      A        B C
my @xpmap = qw( 0 1  1 2 3  3 4  5 6  6 7 8  8 9 10 10 11 12 );
my @sfmap = qw( 0 7 -5 2 9 -3 4 -1 6 -6 1 8 -4 3 10 -2  5 0  );

sub OnPreviewMore {
    my ($self, $event) = @_;

    use ChordPro::Wx::RenderDialog;
    my $d = $self->{d_render} ||= ChordPro::Wx::RenderDialog->new($self, -1, "Tasks");
    my $ret = $d->ShowModal;
    return unless $ret == wxID_OK;
    my @args;
    if ( $d->{cb_task_no_diagrams}->IsChecked ) {
	push( @args, "--no-chord-grids" );
    }
    if ( $d->{cb_task_lyrics_only}->IsChecked ) {
	push( @args, "--lyrics-only",
	      "--define=delegates.abc.omit=1",
	      "--define=delegates.ly.omit=1" );
    }
    if ( $d->{cb_task_decapo}->IsChecked ) {
	push( @args, "--decapo" );
    }

    # Transpose.
    my $xpose_from = $xpmap[$d->{ch_xpose_from}->GetSelection];
    my $xpose_to   = $xpmap[$d->{ch_xpose_to  }->GetSelection];
    my $xpose_acc  = $d->{ch_acc}->GetSelection;
    my $n = $xpose_to - $xpose_from;
    $n += 12 if $n < 0;
    $n += 12 if $xpose_acc == 1; # sharps
    $n -= 12 if $xpose_acc == 2; # flats

    push( @args, "--transpose=$n" );



    my $i = 0;
    for ( @{$state{tasks}} ) {
	if ( $d->{"cb_customtask_$i"}->IsChecked ) {
	    push( @args, "--config", $_->[1] );
	}
	$i++;
    }
    $self->preview( \@args  );
    $self->previewtooltip;
}

sub OnPreviewClose {
    my ( $self, $event ) = @_;
    return unless $self->{sw_e_p}->IsSplit;
    $self->{sw_e_p}->Unsplit(undef);
    $self->previewtooltip;
}

sub OnShowMessages {
    my ( $self, $event ) = @_;
    $self->OnWindowMessages;
}

sub OnStyleNeeded {
    my ( $self, $event ) = @_;
    $self->style_text($self->{t_editor});
}

sub OnInitial {
    my ( $self, $event ) = @_;
    $self->Skip if $self->checksaved;
}

sub OnSashLRChanged {
    my ( $self, $event ) = @_;
    $state{sash}{editor_edit_view} = $self->{sw_e_p}->GetSashPosition;
}

sub OnWindowPreview {
    my ( $self, $event ) = @_;
    if ( $self->{sw_e_p}->IsSplit ) {
	$state{sash}{editor_edit_view} = $self->{sw_e_p}->GetSashPosition;
	$self->{sw_e_p}->Unsplit(undef);
    }
    else {
	$self->{sw_e_p}->SplitVertically( $self->{p_left},
					  $self->{p_right},
					  $state{sash}{editor_edit_view} // 0 );
    }
    $self->previewtooltip;
}

sub OnSashTBChanged {
    my ( $self, $event ) = @_;
    $state{sash}{editor_editview_messages} = $self->{sw_ep_m}->GetSashPosition;
}

sub OnWindowMessages {
    my ( $self, $event ) = @_;
    if ( $self->{sw_ep_m}->IsSplit ) {
	$state{sash}{editor_editview_messages} = $self->{sw_ep_m}->GetSashPosition;
	$self->{sw_ep_m}->Unsplit(undef);
    }
    else {
	$self->{bmb_messages}->SetBackgroundColour(wxNullColour);
	$self->{sw_ep_m}->SplitHorizontally( $self->{p_top},
					     $self->{p_bottom},
					     $state{sash}{editor_editview_messages} // 0 );
    }
    $self->messagestooltip;
}

sub OnMessagesClear {
    my ( $self, $event ) = @_;
    $self->{t_messages}->Clear;
}

sub OnMessagesSave {
    my ( $self, $event ) = @_;
    my $conf = Wx::ConfigBase::Get;
    my $file = $state{messages}{savedas} // "";
    my $fd = Wx::FileDialog->new
      ($self, _T("Choose file to save in"),
       "", $file,
       "*",
       0|wxFD_SAVE|wxFD_OVERWRITE_PROMPT,
       wxDefaultPosition);

=for later

    $fd->SetExtraControlCreator
      ( sub {
          my $parent = shift;
          my $panel = Wx::Panel->new( $parent, wxID_ANY );
          my $cb = Wx::CheckBox->new( $panel, wxID_ANY, _T("Clear messages") );
          my $sz = Wx::BoxSizer->new( wxHORIZONTAL );
          $sz->Add( $cb, 0, wxALIGN_CENTER_VERTICAL, 0 );
          $panel->SetSizer($sz);
          $sz->Fit($panel);
          return $panel;
        } );

=cut

    my $ret = $fd->ShowModal;
    if ( $ret == wxID_OK ) {
	$file = $fd->GetPath;
	$self->log( 'S',  "Messages saved." );
	$self->{t_messages}->SaveFile($file);
	$state{messages}{savedas} = $file;

=for later

	$self->{t_messages}->Clear if $cb->IsChecked;

=cut

    }
    $fd->Destroy;
    return $ret;
}

sub OnHelp_DebugInfo {
    my ( $self, $event ) = @_;
    $state{debuginfo} = wxTheApp->GetTopWindow->GetMenuBar->FindItem($event->GetId)->IsChecked;
}

################ Compatibility ################

# This is to facilitate swapping between TextCtrl and Scintilla.

sub Wx::StyledTextCtrl::SetFont {
    $_[0]->StyleSetFont( $_, $_[1] ) for 0..6;
}

sub Wx::StyledTextCtrl::GetFont {
    $_[0]->StyleGetFont(0, $_[1]);
}

# IsModified, MarkDirty and DiscardEdits need custom patches.
sub Wx::StyledTextCtrl::SetModified {
    $_[1] ? $_[0]->MarkDirty : $_[0]->DiscardEdits;
}

sub Wx::TextCtrl::GetText {
    $_[0]->GetValue;
}

sub Wx::TextCtrl::SetText {
    $_[0]->SetValue($_[1]);
}

sub Wx::TextCtrl::GetLineCount {
    $_[0]->GetNumberOfLines;
}

1;

