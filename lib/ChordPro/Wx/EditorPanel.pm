#! perl

use strict;
use warnings;
use utf8;

# Implementation of ChordPro::Wx::EditorPanel_wxg details.

package ChordPro::Wx::EditorPanel;

# ChordPro::Wx::EditorPanel_wxg is generated by wxGlade and contains
# all UI associated code.

use parent qw( ChordPro::Wx::EditorPanel_wxg );

use Wx qw[:everything];
use Wx::Locale gettext => '_T';
use ChordPro::Wx::Utils;
use ChordPro::Utils qw( demarkup is_macos );

my $stc;

sub new {
    my( $self, $parent, $id, $pos, $size, $style, $name ) = @_;
    $parent = undef              unless defined $parent;
    $id     = -1                 unless defined $id;
    $pos    = wxDefaultPosition  unless defined $pos;
    $size   = wxDefaultSize      unless defined $size;
    $name   = ""                 unless defined $name;

    $self = $self->SUPER::new( $parent, $id, $pos, $size, $style, $name );

    # By default the TextCtrl on MacOS substitutes smart quotes and dashes.
    # Note that OSXDisableAllSmartSubstitutions requires an augmented
    # version of wxPerl.
    $self->{t_source}->OSXDisableAllSmartSubstitutions
      if $self->{t_source}->can("OSXDisableAllSmartSubstitutions");

    # Try Styled Text Control (Scintilla).
    $stc = eval { use Wx::STC; 1 };
    if ( $stc ) {
	$self->setup_scintilla;
    }
    else {
	# Fallback to placeholder Wx::TextCtrl.
	# Fortunately, most methods are compatible.
    }

    $self->Layout;
    return $self;

}

sub log {
    my $self = shift;
    wxTheApp->GetTopWindow->log(@_);
}

################ API Functions ################

sub setup_scintilla {
    my ( $self ) = @_;

    # Replace the placeholder Wx::TextCtrl.
    my $stc = Wx::StyledTextCtrl->new( $self->{sz_source}->GetStaticBox,
				       wxID_ANY );
    $self->{sz_source}->Replace( $self->{t_source}, $stc, 1 );
    $self->{t_source}->Destroy;
    $self->{t_source} = $stc;
    $self->{sz_source}->Layout;
    $stc->SetLexer(wxSTC_LEX_CONTAINER);
    $stc->SetKeyWords(0, [ "title",
			   "subtitle",
			   "album",
			   "arranger",
			   "artist",
			   "capo",
			   "composer",
			   "copyright",
			   "duration",
			   "key",
			   "lyricist",
			   "sorttitle",
			   "tempo",
			   "time",
			   "year",
			   "chord",
			   "end_of_grid",
			   "new_physical_page",
			   "start_of_bridge",
			   "titles",
			   "end_of_tab",
			   "define",
			   "column_break",
			   "grid",
			   "new_page",
			   "comment",
			   "columns",
			   "start_of_verse",
			   "image",
			   "comment_box",
			   "comment_italic",
			   "highlight",
			   "no_grid",
			   "diagrams",
			   "start_of_tab",
			   "meta",
			   "chorus",
			   "pagesize",
			   "new_song",
			   "start_of_grid",
			   "transpose",
			   "end_of_bridge",
			   "pagetype",
			   "end_of_verse",
			   "start_of_chorus",
			   "end_of_chorus"
			 ]);

    Wx::Event::EVT_STC_STYLENEEDED($self, -1, $self->can('OnStyleNeeded'));

    $stc->StyleClearAll;
    # 0 - basic
    # 1 - comments
    $stc->StyleSetSpec( 1, "bold,fore:grey" );
    # 2 - Keywords
    $stc->StyleSetSpec( 2, "bold,fore:grey" );
    # 3 - Brackets
    $stc->StyleSetSpec( 3, "bold,fore:grey" );
    # 4 - Chords
    $stc->StyleSetSpec( 4, "fore:red" );
    # 5 - Directives
    $stc->StyleSetSpec( 5, "bold,fore:indigo" );
    # 6 - Directive arguments
    $stc->StyleSetSpec( 6, "fore:orange" );

    # For linenumbers.
    $stc->SetMarginType( 1, wxSTC_MARGIN_NUMBER );
    $stc->SetMarginMask( 1, 0 );
    $stc->SetMarginWidth( 1, 40 ); # TODO
}

################ API Functions ################

sub refresh {
    my ( $self ) = @_;
    # Enable/disable menu items.
    for ( $self->GetParent->{main_menubar} ) {
	$_->FindItem(wxID_UNDO)->Enable($self->{t_source}->CanUndo);
	$_->FindItem(wxID_REDO)->Enable($self->{t_source}->CanRedo);
    }
}

sub open {
    my ( $self, $create ) = @_;
    return unless $self->checksaved;

    if ( $create ) {
	$self->newfile;
    }
    else {
	$self->opendialog;
    }
}

sub opendialog {
    my ($self) = @_;
    my $fd = Wx::FileDialog->new
      ($self, _T("Choose ChordPro file"),
       "", "",
       "ChordPro files (*.cho,*.crd,*.chopro,*.chord,*.chordpro,*.pro)|*.cho;*.crd;*.chopro;*.chord;*.chordpro;*.pro".
       (is_macos ? ";*.txt" : "|All files|*.*"),
       0|wxFD_OPEN|wxFD_FILE_MUST_EXIST,
       wxDefaultPosition);
    my $ret = $fd->ShowModal;
    if ( $ret == wxID_OK ) {
	$self->openfile( $fd->GetPath, 1 );
    }
    $fd->Destroy;
}

sub openfile {
    my ( $self, $file, $checked ) = @_;

    # File tests fail on Windows, so bypass when already checked.
    unless ( $checked || -f -r $file ) {
	$self->log( 'W',  "Error opening $file: $!",);
	my $md = Wx::MessageDialog->new
	  ( $self,
	    "Error opening $file: $!",
	    "File open error",
	    wxOK | wxICON_ERROR );
	my $ret = $md->ShowModal;
	$md->Destroy;
	return;
    }
    unless ( $self->{t_source}->LoadFile($file) ) {
	$self->log( 'W',  "Error opening $file: $!",);
	my $md = Wx::MessageDialog->new
	  ( $self,
	    "Error opening $file: $!",
	    "File load error",
	    wxOK | wxICON_ERROR );
	$md->ShowModal;
	$md->Destroy;
	return;
    }
    #### TODO: Get rid of selection on Windows
    $self->{_currentfile} = $file;
    if ( $self->{t_source}->GetText =~ /^\{\s*t(?:itle)?[: ]+([^\}]*)\}/m ) {
	my $title = demarkup($1);
	my $n = $self->{t_source}->GetLineCount;
	$self->log( 'S', "Loaded: $title ($n line" . ( $n == 1 ? "" : "s" ) . ")");
	$self->{sz_source}->GetStaticBox->SetLabel($title);
    }
    else {
	my $n = $self->{t_source}->GetLineCount;
	$self->log( 'S', "Loaded: $file ($n line" . ( $n == 1 ? "" : "s" ) . ")");
    }
    $self->SetTitle( $self->{_windowtitle} = $file);

    $self->{prefs_xpose} = 0;
    $self->{prefs_xposesharp} = 0;
    return 1;
}

sub newfile {
    my ( $self ) = @_;
    undef $self->{_currentfile};

    my $file = $self->{prefs_tmplfile};
    my $content = "{title: New Song}\n\n";
    if ( $file ) {
	$self->log( 'I', "Loading template $file" );
	if ( -f -r $file ) {
	    if ( $self->{t_source}->LoadFile($file) ) {
		$content = "";
	    }
	    else {
		$content = "# Error opening template $file: $!\n\n" . $content;
	    }
	}
	else {
	    $content = "# Error opening template $file: $!\n\n" . $content;
	}
     }
    $self->{t_source}->SetText($content) unless $content eq "";
    $self->{t_source}->SetModified(0);
    $self->log( 'S', "New file");
    $self->{prefs_xpose} = 0;
    $self->{prefs_xposesharp} = 0;
}

sub checksaved {
    my ( $self ) = @_;
    return 1 unless ( $self->{t_source} && $self->{t_source}->IsModified );
    if ( $self->{_currentfile} ) {
	my $md = Wx::MessageDialog->new
	  ( $self,
	    "File " . $self->{_currentfile} . " has been changed.\n".
	    "Do you want to save your changes?",
	    "File has changed",
	    0 | wxCANCEL | wxYES_NO | wxYES_DEFAULT | wxICON_QUESTION );
	my $ret = $md->ShowModal;
	$md->Destroy;
	return if $ret == wxID_CANCEL;
	if ( $ret == wxID_YES ) {
	    $self->save_as( $self->{_currentfile} );
	}
    }
    else {
	my $md = Wx::MessageDialog->new
	  ( $self,
	    "Do you want to save your changes?",
	    "Contents has changed",
	    0 | wxCANCEL | wxYES_NO | wxYES_DEFAULT | wxICON_QUESTION );
	my $ret = $md->ShowModal;
	$md->Destroy;
	return if $ret == wxID_CANCEL;
	if ( $ret == wxID_YES ) {
	    return if $self->OnSaveAs == wxID_CANCEL;
	}
    }
    return 1;
}

sub saveas {
    my ( $self ) = @_;
    my $fd = Wx::FileDialog->new
      ($self, _T("Choose output file"),
       "", "",
       "*.cho",
       0|wxFD_SAVE|wxFD_OVERWRITE_PROMPT,
       wxDefaultPosition);
    my $ret = $fd->ShowModal;
    if ( $ret == wxID_OK ) {
	$self->save_as( $self->{_currentfile} = $fd->GetPath );
    }
    $fd->Destroy;
    return $ret;
}

sub save_as {
    my ( $self, $file ) = @_;
    $self->{t_source}->SaveFile($file);
    $self->SetTitle( $self->{_windowtitle} = $file);
    $self->log( 'S',  "Saved." );
}

sub save {
    my ( $self ) = @_;
    goto &saveas unless $self->{_currentfile};
    $self->save_as( $self->{_currentfile} );
}

sub undo {
    my ( $self ) = @_;
    $self->{t_source}->CanUndo
      ? $self->{t_source}->Undo
	: $self->log( 'I', "Sorry, can't undo yet");
}

sub redo {
    my ( $self ) = @_;
    $self->{t_source}->CanRedo
      ? $self->{t_source}->Redo
	: $self->log( 'I', "Sorry, can't redo yet");
}

sub cut {
    my ( $self ) = @_;
    $self->{t_source}->Cut;
}

sub paste {
    my ( $self ) = @_;
    $self->{t_source}->Paste;
}

sub delete {
    my ( $self ) = @_;
    my ( $from, $to ) = $self->{t_source}->GetSelection;
    $self->{t_source}->Remove( $from, $to ) if $from < $to;
}

sub alert {
    my ( $self ) = @_;
    $self->{b_msgs}->SetBackgroundColour(Wx::Colour->new(255, 0, 0));
}

################ Event Handlers ################

sub OnText {
    my ($self, $event) = @_;
    $self->{t_source}->SetModified(1);
}

sub OnPreferences {
    my ( $self, $event ) = @_;
    $self->GetParent->OnPreferences($event);
}

sub OnPreview {
    my ( $self, $event ) = @_;
    $event = Wx::CommandEvent->new( wxEVT_COMMAND_MENU_SELECTED,
				    $self->wxID_PREVIEW );
    Wx::PostEvent( $self->GetParent, $event );
}

sub OnShowMessages {
    my ( $self, $event ) = @_;
    $self->{b_msgs}->SetBackgroundColour(wxNullColour);
    $self->GetParent->{_prev_mode} = "EDIT";
    $self->GetParent->select_mode("MSGS");
}

sub OnStyleNeeded {
    my ( $self, $event ) = @_;
    my $stc = $self->{t_source};
    my $start = $stc->GetEndStyled;

    # Scintilla uses byte indices.
    use Encode;
    my $text  = Encode::encode_utf8($stc->GetText);

    while ( $text =~ /^(#.*)/gm ) {
	my $l = length($1);
	$stc->StartStyling( pos($text)-$l, 0 );
	$stc->SetStyling( $l, 1 );
    }

    pos($text) = 0;
    while ( $text =~ /^\{([-\w!]+)([: ]+)(.*)\}/gm ) {
	$stc->StartStyling( pos($text)-length($1.$2.$3)-2, 0 );
	$stc->SetStyling( 1, 3 );
	$stc->StartStyling( pos($text)-length($1.$2.$3)-1, 0 );
	$stc->SetStyling( length($1), 5 );
	$stc->StartStyling( pos($text)-length($2.$3)-1, 0 );
	$stc->SetStyling( length($2), 3 );
	$stc->StartStyling( pos($text)-length($3)-1, 0 );
	$stc->SetStyling( length($3), 6 );
	$stc->StartStyling( pos($text)-1, 0 );
	$stc->SetStyling( 1, 3 );
    }

    pos($text) = 0;
    while ( $text =~ /\[(.*?)\]/gm ) {
	$stc->StartStyling( pos($text)-length($1)-2, 0 );
	$stc->SetStyling( 1, 3 );
	$stc->StartStyling( pos($text)-length($1)-1, 0 );
	$stc->SetStyling( length($1), 4 );
	$stc->StartStyling( pos($text)-1, 0 );
	$stc->SetStyling( 1, 3 );
    }
}

################ Compatibility ################

# This is to facilitate swapping between TextCtrl and Scintilla.

sub Wx::StyledTextCtrl::SetFont {
    $_[0]->StyleSetFont( $_, $_[1] ) for 0..6;
}

sub Wx::StyledTextCtrl::GetFont {
    $_[0]->StyleGetFont(0, $_[1]);
}

# IsModified, MarkDirty and DiscardEdits need custom patches.
sub Wx::StyledTextCtrl::SetModified {
    $_[1] ? $_[0]->MarkDirty : $_[0]->DiscardEdits;
}

sub Wx::TextCtrl::GetText {
    $_[0]->GetValue;
}

sub Wx::TextCtrl::SetText {
    $_[0]->SetValue;
}

sub Wx::TextCtrl::GetLineCount {
    $_[0]->GetNumberOfLines;
}

1;

