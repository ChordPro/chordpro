#! perl

use strict;
use warnings;
use utf8;

# Implementation of ChordPro::Wx::SongbookExport_wxg details.

package ChordPro::Wx::SongbookExport;

# ChordPro::Wx::SoongbookExport_wxg is generated by wxGlade and contains
# all UI associated code.

use parent qw( ChordPro::Wx::SongbookExport_wxg );

use Wx qw[:everything];
use Wx::Locale gettext => '_T';
use constant CFGBASE => "songbookexport/";
use Encode qw( decode_utf8 encode_utf8 );
use ChordPro::Utils qw(demarkup);

sub new {
    my $self = shift;
    $self = $self->SUPER::new(@_);

    my $conf = Wx::ConfigBase::Get;
    $self->{t_exportfolder}->SetValue($conf->Read( CFGBASE . "folder" ) // "");
    $self->{t_exporttitle}->SetValue($conf->Read( CFGBASE . "title" ) // "");

    return $self;
}

################ Event handlers ################

sub OnAccept {
    my ( $self, $event ) = @_;

    my $folder = $self->{t_exportfolder}->GetValue;
    unless ( $folder ) {
	my $md = Wx::MessageDialog->new
	  ( $self,
	    "Please select a folder!",
	    "No folder selected",
	    wxOK | wxICON_ERROR );
	my $ret = $md->ShowModal;
	$md->Destroy;
	return;
    }

    opendir( my $dir, $folder )
      or do {
	my $md = Wx::MessageDialog->new
	  ( $self,
	    "Error opening folder $folder: $!",
	    "Error",
	    wxOK | wxICON_ERROR );
	my $ret = $md->ShowModal;
	$md->Destroy;
	return;
      };
    my @files = sort grep {
	m/^[^.].*\.(cho|crd|chopro|chord|chordpro|pro)$/
    } readdir($dir);
    my $n = @files;
    Wx::LogStatus("Found $n ChordPro file" .
		      ( $n == 1 ? "" : "s" ) .
		      " in $folder");

    my $conf = Wx::ConfigBase::Get;
    $conf->Write( CFGBASE . "folder", $self->{t_exportfolder}->GetValue // "" );
    $conf->Write( CFGBASE . "title", $self->{t_exporttitle}->GetValue // "" );

    my $filelist = join( "\n",
			 map { "$folder/" . decode_utf8($_) } @files );


    # Hide the dialog for the progress dialog.
    $self->GetParent->{d_sbexport}->Show(0);

    my $dialog;
    my $pcb = sub {
	my $ctl = shift;

	$self->GetParent->_info( "Song " . $ctl->{index} . " of " .
		      $ctl->{songs} . ": " .
		      demarkup($ctl->{title}) . "\n" )
	  if $ctl->{index} && $ctl->{songs} > 1;

	if ( $ctl->{index} == 0 ) {
	    return 1 unless $ctl->{songs} > 1;
	    $dialog = Wx::ProgressDialog->new
	      ( 'Processing...',
		'Starting',
		$ctl->{songs}, $self,
		wxPD_CAN_ABORT|wxPD_AUTO_HIDE|wxPD_APP_MODAL|
		wxPD_ELAPSED_TIME|wxPD_ESTIMATED_TIME|wxPD_REMAINING_TIME );
	}
	elsif ( $dialog ) {
	    $dialog->Update( $ctl->{index},
			     "Song " . $ctl->{index} . " of " .
			     $ctl->{songs} . ": " .
			     demarkup($ctl->{title}) )
	      and return 1;
	    Wx::LogStatus( "Processing cancelled." );
	    return;
	}

	return 1;
    };

    $self->GetParent->preview( "--filelist", \$filelist,
			       "--progress_callback" => $pcb );

    $dialog->Destroy if $dialog;
    $event->Skip;
}

sub OnCancel {
    my ( $self, $event ) = @_;
    $event->Skip;
}

sub OnFolderDialog {
    my ( $self, $event ) = @_;
    my $fd = Wx::DirDialog->new
      ($self, _T("Choose folder"),
       $self->{t_exportfolder}->GetValue || "",
       0|wxDD_DIR_MUST_EXIST,
       wxDefaultPosition);
    my $ret = $fd->ShowModal;
    if ( $ret == wxID_OK ) {
	my $file = $fd->GetPath;
	$self->{t_exportfolder}->SetValue($file);
    }
    $fd->Destroy;
}

1;
